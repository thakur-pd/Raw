import telebot
from telebot import types
import re
import json
import os
from datetime import datetime

# Bot Token
BOT_TOKEN = "8424348378:AAEVh3YVP85k-t2JDy0B3aiFtnWjLNxdTwo"
bot = telebot.TeleBot(BOT_TOKEN)

# User data storage
user_requests = {}
user_settings = {}

# ================== PARSER FUNCTIONS ==================

def parse_raw_request(raw_data):
    try:
        lines = raw_data.strip().split('\n')
        first_line = lines[0].strip()
        parts = first_line.split(' ')
        method = parts[0].upper()
        path = parts[1] if len(parts) > 1 else '/'
        
        if ' ' in path:
            path = path.split(' ')[0]
        
        headers = {}
        body = ""
        header_end = False
        body_lines = []
        cookies = {}
        
        for i, line in enumerate(lines[1:], 1):
            original_line = line
            line = line.strip()
            
            if line == "":
                header_end = True
                continue
            
            if not header_end:
                if ':' in line:
                    key, value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()
                    headers[key] = value
                    
                    if key.lower() == 'cookie':
                        cookie_pairs = value.split(';')
                        for pair in cookie_pairs:
                            if '=' in pair:
                                ck, cv = pair.strip().split('=', 1)
                                cookies[ck.strip()] = cv.strip()
            else:
                body_lines.append(original_line.strip())
        
        body = '\n'.join(body_lines)
        host = headers.get('Host', headers.get('host', ''))
        origin = headers.get('origin', headers.get('Origin', ''))
        referer = headers.get('referer', headers.get('Referer', ''))
        
        if 'https' in origin.lower() or 'https' in referer.lower():
            protocol = 'https'
        else:
            protocol = 'https'
        
        full_url = f"{protocol}://{host}{path}"
        
        return {
            'method': method,
            'url': full_url,
            'path': path,
            'host': host,
            'protocol': protocol,
            'headers': headers,
            'body': body,
            'cookies': cookies,
            'raw': raw_data
        }
    except Exception as e:
        return None

# ================== CODE GENERATORS ==================

def generate_php_curl(parsed):
    headers_list = []
    for i, (key, value) in enumerate(parsed['headers'].items()):
        value_escaped = value.replace("'", "\\'").replace('"', '\\"')
        headers_list.append(f"    {i} => '{key}: {value_escaped}'")
    
    headers_array = ',\n'.join(headers_list)
    body_escaped = parsed['body'].replace("'", "\\'")
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    php_code = f"""<?php

/**
 * Generated by Raw Request Converter Bot
 * Time: {now}
 * Method: {parsed['method']}
 * URL: {parsed['url']}
 */

$url = '{parsed['url']}';

$data = '{body_escaped}';

$headers = array(
{headers_array}
);

$ch = curl_init();

curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, '{parsed['method']}');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
curl_setopt($ch, CURLOPT_MAXREDIRS, 10);
curl_setopt($ch, CURLOPT_TIMEOUT, 30);
curl_setopt($ch, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1);
curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);
curl_setopt($ch, CURLOPT_ENCODING, 'gzip, deflate, br');

$response = curl_exec($ch);
$httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
$error = curl_error($ch);

curl_close($ch);

if ($error) {{
    echo "Error: " . $error;
}} else {{
    echo "HTTP Code: " . $httpCode . "\\n";
    echo "Response: " . $response;
}}

?>"""
    
    return php_code


def generate_python_requests(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"')
        headers_list.append(f'    "{key}": "{value_escaped}"')
    
    headers_dict = ',\n'.join(headers_list)
    
    try:
        body_json = json.loads(parsed['body']) if parsed['body'] else {}
        body_formatted = json.dumps(body_json, indent=4)
        use_json = True
    except:
        body_formatted = f'"""{parsed["body"]}"""'
        use_json = False
    
    method_lower = parsed['method'].lower()
    if method_lower not in ['get', 'post', 'put', 'delete', 'patch', 'head', 'options']:
        method_lower = 'post'
    
    data_param = 'json=data' if use_json else 'data=data'
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    python_code = f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generated by Raw Request Converter Bot
Time: {now}
Method: {parsed['method']}
URL: {parsed['url']}
"""

import requests
import json
import warnings

warnings.filterwarnings('ignore')

url = "{parsed['url']}"

headers = {{
{headers_dict}
}}

data = {body_formatted}

try:
    response = requests.{method_lower}(
        url,
        headers=headers,
        {data_param},
        verify=False,
        timeout=30
    )
    
    print(f"Status Code: {{response.status_code}}")
    print(f"Response: {{response.text}}")
    
    try:
        json_response = response.json()
        print(f"JSON: {{json.dumps(json_response, indent=2)}}")
    except:
        pass
        
except requests.exceptions.RequestException as e:
    print(f"Error: {{e}}")
'''
    
    return python_code


def generate_python_httpx(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"')
        headers_list.append(f'    "{key}": "{value_escaped}"')
    
    headers_dict = ',\n'.join(headers_list)
    
    try:
        body_json = json.loads(parsed['body']) if parsed['body'] else {}
        body_formatted = json.dumps(body_json, indent=4)
        use_json = True
    except:
        body_formatted = f'"""{parsed["body"]}"""'
        use_json = False
    
    method_lower = parsed['method'].lower()
    data_param = 'json=data' if use_json else 'content=data'
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    httpx_code = f'''#!/usr/bin/env python3
"""
Generated by Raw Request Converter Bot (HTTPX Async)
Time: {now}
"""

import httpx
import asyncio
import json

url = "{parsed['url']}"

headers = {{
{headers_dict}
}}

data = {body_formatted}

async def make_request():
    async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
        response = await client.{method_lower}(
            url,
            headers=headers,
            {data_param}
        )
        
        print(f"Status: {{response.status_code}}")
        print(f"Response: {{response.text}}")
        return response

if __name__ == "__main__":
    asyncio.run(make_request())
'''
    
    return httpx_code


def generate_curl_command(parsed):
    curl_parts = [f"curl -X {parsed['method']}"]
    curl_parts.append(f"  '{parsed['url']}'")
    
    for key, value in parsed['headers'].items():
        value_escaped = value.replace("'", "'\\''")
        curl_parts.append(f"  -H '{key}: {value_escaped}'")
    
    if parsed['body']:
        body_escaped = parsed['body'].replace("'", "'\\''").replace('\n', '')
        curl_parts.append(f"  -d '{body_escaped}'")
    
    curl_parts.append("  --compressed")
    curl_parts.append("  -k")
    curl_parts.append("  -v")
    
    return ' \\\n'.join(curl_parts)


def generate_nodejs_fetch(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"').replace("'", "\\'")
        headers_list.append(f'        "{key}": "{value_escaped}"')
    
    headers_obj = ',\n'.join(headers_list)
    body_escaped = parsed['body'].replace('`', '\\`').replace('$', '\\$')
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    nodejs_code = f'''/**
 * Generated by Raw Request Converter Bot
 * Time: {now}
 * Node.js Fetch API
 */

const fetch = require('node-fetch');

const url = "{parsed['url']}";

const options = {{
    method: "{parsed['method']}",
    headers: {{
{headers_obj}
    }},
    body: `{body_escaped}`
}};

process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

async function makeRequest() {{
    try {{
        const response = await fetch(url, options);
        const data = await response.text();
        
        console.log("Status:", response.status);
        console.log("Body:", data);
        
        try {{
            const jsonData = JSON.parse(data);
            console.log("JSON:", JSON.stringify(jsonData, null, 2));
        }} catch (e) {{}}
        
    }} catch (error) {{
        console.error("Error:", error.message);
    }}
}}

makeRequest();
'''
    
    return nodejs_code


def generate_nodejs_axios(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"').replace("'", "\\'")
        headers_list.append(f'        "{key}": "{value_escaped}"')
    
    headers_obj = ',\n'.join(headers_list)
    
    try:
        body_json = json.loads(parsed['body']) if parsed['body'] else {}
        body_formatted = json.dumps(body_json, indent=8)
    except:
        body_formatted = f'`{parsed["body"]}`'
    
    axios_code = f'''/**
 * Generated by Raw Request Converter Bot
 * Node.js Axios
 */

const axios = require('axios');
const https = require('https');

const url = "{parsed['url']}";

const config = {{
    method: "{parsed['method'].lower()}",
    url: url,
    headers: {{
{headers_obj}
    }},
    data: {body_formatted},
    httpsAgent: new https.Agent({{ rejectUnauthorized: false }}),
    timeout: 30000
}};

axios(config)
    .then(response => {{
        console.log("Status:", response.status);
        console.log("Data:", JSON.stringify(response.data, null, 2));
    }})
    .catch(error => {{
        console.error("Error:", error.message);
        if (error.response) {{
            console.log("Response:", error.response.data);
        }}
    }});
'''
    
    return axios_code


def generate_javascript_fetch(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"').replace("'", "\\'")
        headers_list.append(f'        "{key}": "{value_escaped}"')
    
    headers_obj = ',\n'.join(headers_list)
    body_escaped = parsed['body'].replace('`', '\\`').replace('$', '\\$')
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    js_code = f'''/**
 * Generated by Raw Request Converter Bot
 * Browser JavaScript Fetch API
 * Time: {now}
 */

const url = "{parsed['url']}";

const options = {{
    method: "{parsed['method']}",
    headers: {{
{headers_obj}
    }},
    body: `{body_escaped}`,
    credentials: 'include',
    mode: 'cors'
}};

fetch(url, options)
    .then(response => {{
        console.log("Status:", response.status);
        return response.json();
    }})
    .then(data => {{
        console.log("Response:", data);
    }})
    .catch(error => {{
        console.error("Error:", error);
    }});
'''
    
    return js_code


def generate_golang(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"')
        headers_list.append(f'    req.Header.Set("{key}", "{value_escaped}")')
    
    headers_code = '\n'.join(headers_list)
    body_escaped = parsed['body'].replace('"', '\\"').replace('\n', '\\n')
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    go_code = f'''// Generated by Raw Request Converter Bot
// Time: {now}

package main

import (
    "crypto/tls"
    "fmt"
    "io/ioutil"
    "net/http"
    "strings"
    "time"
)

func main() {{
    url := "{parsed['url']}"
    method := "{parsed['method']}"
    payload := strings.NewReader(`{body_escaped}`)

    tr := &http.Transport{{
        TLSClientConfig: &tls.Config{{InsecureSkipVerify: true}},
    }}
    
    client := &http.Client{{
        Transport: tr,
        Timeout:   30 * time.Second,
    }}

    req, err := http.NewRequest(method, url, payload)
    if err != nil {{
        fmt.Println("Error:", err)
        return
    }}

{headers_code}

    resp, err := client.Do(req)
    if err != nil {{
        fmt.Println("Error:", err)
        return
    }}
    defer resp.Body.Close()

    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println("Status:", resp.StatusCode)
    fmt.Println("Response:", string(body))
}}
'''
    
    return go_code


def generate_java(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"')
        headers_list.append(f'        connection.setRequestProperty("{key}", "{value_escaped}");')
    
    headers_code = '\n'.join(headers_list)
    body_escaped = parsed['body'].replace('"', '\\"').replace('\n', '\\n')
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    java_code = f'''/**
 * Generated by Raw Request Converter Bot
 * Time: {now}
 */

import java.io.*;
import java.net.*;
import javax.net.ssl.*;

public class HttpRequest {{
    public static void main(String[] args) throws Exception {{
        String url = "{parsed['url']}";
        String method = "{parsed['method']}";
        String body = "{body_escaped}";

        TrustManager[] trustAllCerts = new TrustManager[] {{
            new X509TrustManager() {{
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {{ return null; }}
                public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {{}}
                public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {{}}
            }}
        }};

        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        URL obj = new URL(url);
        HttpURLConnection connection = (HttpURLConnection) obj.openConnection();
        connection.setRequestMethod(method);
        connection.setDoOutput(true);
        connection.setConnectTimeout(30000);
        connection.setReadTimeout(30000);

{headers_code}

        try (OutputStream os = connection.getOutputStream()) {{
            byte[] input = body.getBytes("utf-8");
            os.write(input, 0, input.length);
        }}

        int responseCode = connection.getResponseCode();
        System.out.println("Status: " + responseCode);

        BufferedReader in = new BufferedReader(new InputStreamReader(
            responseCode >= 400 ? connection.getErrorStream() : connection.getInputStream()
        ));
        String inputLine;
        StringBuilder response = new StringBuilder();
        while ((inputLine = in.readLine()) != null) {{
            response.append(inputLine);
        }}
        in.close();

        System.out.println("Response: " + response.toString());
    }}
}}
'''
    
    return java_code


def generate_csharp(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        if key.lower() not in ['content-type', 'content-length', 'host']:
            value_escaped = value.replace('"', '\\"')
            headers_list.append(f'            client.DefaultRequestHeaders.TryAddWithoutValidation("{key}", "{value_escaped}");')
    
    headers_code = '\n'.join(headers_list)
    content_type = parsed['headers'].get('content-type', parsed['headers'].get('Content-Type', 'application/json'))
    body_escaped = parsed['body'].replace('"', '\\"').replace('\n', '\\n')
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    csharp_code = f'''/*
 * Generated by Raw Request Converter Bot
 * Time: {now}
 */

using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

class Program
{{
    static async Task Main(string[] args)
    {{
        var handler = new HttpClientHandler()
        {{
            ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true
        }};

        using (var client = new HttpClient(handler))
        {{
            client.Timeout = TimeSpan.FromSeconds(30);
            
{headers_code}

            var url = "{parsed['url']}";
            var content = new StringContent("{body_escaped}", Encoding.UTF8, "{content_type}");

            try
            {{
                HttpResponseMessage response = await client.PostAsync(url, content);
                var responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine("Status: " + (int)response.StatusCode);
                Console.WriteLine("Response: " + responseBody);
            }}
            catch (Exception ex)
            {{
                Console.WriteLine("Error: " + ex.Message);
            }}
        }}
    }}
}}
'''
    
    return csharp_code


def generate_ruby(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace('"', '\\"').replace("'", "\\'")
        headers_list.append(f"  '{key}' => '{value_escaped}'")
    
    headers_hash = ',\n'.join(headers_list)
    body_escaped = parsed['body'].replace("'", "\\'")
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    ruby_code = f'''#!/usr/bin/env ruby
# Generated by Raw Request Converter Bot
# Time: {now}

require 'net/http'
require 'uri'
require 'json'
require 'openssl'

url = URI.parse('{parsed['url']}')

http = Net::HTTP.new(url.host, url.port)
http.use_ssl = (url.scheme == 'https')
http.verify_mode = OpenSSL::SSL::VERIFY_NONE
http.read_timeout = 30
http.open_timeout = 30

headers = {{
{headers_hash}
}}

request = Net::HTTP::{parsed['method'].capitalize}.new(url.request_uri, headers)
request.body = '{body_escaped}'

begin
  response = http.request(request)
  puts "Status: #{{response.code}}"
  puts "Response: #{{response.body}}"
rescue => e
  puts "Error: #{{e.message}}"
end
'''
    
    return ruby_code


def generate_php_guzzle(parsed):
    headers_list = []
    for key, value in parsed['headers'].items():
        value_escaped = value.replace("'", "\\'")
        headers_list.append(f"        '{key}' => '{value_escaped}'")
    
    headers_array = ',\n'.join(headers_list)
    body_escaped = parsed['body'].replace("'", "\\'")
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    guzzle_code = f'''<?php
/**
 * Generated by Raw Request Converter Bot
 * PHP Guzzle HTTP Client
 * Time: {now}
 * 
 * Install: composer require guzzlehttp/guzzle
 */

require 'vendor/autoload.php';

use GuzzleHttp\\Client;
use GuzzleHttp\\Exception\\RequestException;

$client = new Client([
    'timeout' => 30,
    'verify' => false,
    'http_errors' => false
]);

$url = '{parsed['url']}';

$options = [
    'headers' => [
{headers_array}
    ],
    'body' => '{body_escaped}'
];

try {{
    $response = $client->request('{parsed['method']}', $url, $options);
    
    $statusCode = $response->getStatusCode();
    $body = $response->getBody()->getContents();
    
    echo "Status: " . $statusCode . "\\n";
    echo "Response: " . $body . "\\n";
    
}} catch (RequestException $e) {{
    echo "Error: " . $e->getMessage() . "\\n";
}}

?>'''
    
    return guzzle_code

# ================== KEYBOARDS ==================

def get_main_keyboard():
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    markup.add(
        types.KeyboardButton("üìù Convert Request"),
        types.KeyboardButton("üìö History"),
        types.KeyboardButton("‚öôÔ∏è Settings"),
        types.KeyboardButton("‚ùì Help")
    )
    return markup

def get_format_keyboard():
    markup = types.InlineKeyboardMarkup(row_width=2)
    markup.add(
        types.InlineKeyboardButton("üêò PHP cURL", callback_data="format_php"),
        types.InlineKeyboardButton("üêç Python Requests", callback_data="format_python"),
        types.InlineKeyboardButton("üêç Python HTTPX", callback_data="format_httpx"),
        types.InlineKeyboardButton("üìü cURL Command", callback_data="format_curl"),
        types.InlineKeyboardButton("üíö Node.js Fetch", callback_data="format_nodejs"),
        types.InlineKeyboardButton("üíö Node.js Axios", callback_data="format_axios"),
        types.InlineKeyboardButton("üåê JS Browser", callback_data="format_jsbrowser"),
        types.InlineKeyboardButton("üêπ Golang", callback_data="format_golang"),
        types.InlineKeyboardButton("‚òï Java", callback_data="format_java"),
        types.InlineKeyboardButton("üíú C#", callback_data="format_csharp"),
        types.InlineKeyboardButton("üíé Ruby", callback_data="format_ruby"),
        types.InlineKeyboardButton("üêò PHP Guzzle", callback_data="format_guzzle"),
        types.InlineKeyboardButton("üì¶ All Formats", callback_data="format_all"),
        types.InlineKeyboardButton("üìÅ Download All", callback_data="download_all")
    )
    return markup

def get_back_keyboard():
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("üîô Back to Formats", callback_data="back_formats"))
    return markup

# ================== BOT HANDLERS ==================

@bot.message_handler(commands=['start'])
def start_command(message):
    user_id = message.from_user.id
    user_requests[user_id] = []
    
    welcome_text = (
        "üöÄ *Raw Request Converter Bot*\n\n"
        "Welcome! Main aapki raw HTTP requests ko convert karta hoon:\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üìå *Supported Formats:*\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üêò PHP cURL & Guzzle\n"
        "üêç Python Requests & HTTPX\n"
        "üìü cURL Command\n"
        "üíö Node.js Fetch & Axios\n"
        "üåê Browser JavaScript\n"
        "üêπ Golang\n"
        "‚òï Java\n"
        "üíú C# (.NET)\n"
        "üíé Ruby\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "üìù *Kaise use kare:*\n"
        "Simply raw HTTP request paste karo!\n\n"
        "üîó Commands: /help for more info"
    )
    bot.send_message(
        message.chat.id, 
        welcome_text, 
        parse_mode='Markdown',
        reply_markup=get_main_keyboard()
    )

@bot.message_handler(commands=['help'])
def help_command(message):
    help_text = (
        "üìñ *Complete Help Guide*\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üìù *Raw Request Format:*\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "```\n"
        "POST /api/endpoint HTTP/1.1\n"
        "Host: example.com\n"
        "Content-Type: application/json\n\n"
        "{\"key\": \"value\"}\n"
        "```\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üîß *Supported Methods:*\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "‚Ä¢ GET, POST, PUT, DELETE\n"
        "‚Ä¢ PATCH, HEAD, OPTIONS\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "üìã *Commands:*\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        "/start - Bot restart karo\n"
        "/help - Ye help message\n"
        "/example - Example dekho\n"
        "/clear - History clear karo\n"
        "/stats - Your stats"
    )
    bot.send_message(message.chat.id, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['example'])
def example_command(message):
    example_text = (
        "üìù *Example Raw Request:*\n\n"
        "```\n"
        "POST /api/login HTTP/1.1\n"
        "Host: api.example.com\n"
        "Content-Type: application/json\n"
        "User-Agent: Mozilla/5.0\n\n"
        "{\"username\": \"test\", \"password\": \"123\"}\n"
        "```\n\n"
        "üëÜ Is format me request bhejo!"
    )
    bot.send_message(message.chat.id, example_text, parse_mode='Markdown')

@bot.message_handler(commands=['clear'])
def clear_command(message):
    user_id = message.from_user.id
    user_requests[user_id] = []
    bot.reply_to(message, "‚úÖ History cleared successfully!")

@bot.message_handler(commands=['stats'])
def stats_command(message):
    user_id = message.from_user.id
    request_count = len(user_requests.get(user_id, []))
    
    stats_text = (
        "üìä *Your Statistics*\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üë§ User ID: `{user_id}`\n"
        f"üìù Requests Converted: {request_count}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    )
    bot.send_message(message.chat.id, stats_text, parse_mode='Markdown')

@bot.message_handler(func=lambda m: m.text == "üìù Convert Request")
def convert_prompt(message):
    bot.send_message(
        message.chat.id, 
        "üìù *Raw HTTP request paste karo:*\n\nSimply request copy karke yahan bhej do!",
        parse_mode='Markdown'
    )

@bot.message_handler(func=lambda m: m.text == "üìö History")
def show_history(message):
    user_id = message.from_user.id
    history = user_requests.get(user_id, [])
    
    if not history:
        bot.send_message(message.chat.id, "üì≠ No history found. Start converting requests!")
        return
    
    history_text = "üìö *Your Recent Requests:*\n\n"
    for i, req in enumerate(history[-5:], 1):
        history_text += f"{i}. `{req['method']} {req['url'][:40]}...`\n"
    
    bot.send_message(message.chat.id, history_text, parse_mode='Markdown')

@bot.message_handler(func=lambda m: m.text == "‚öôÔ∏è Settings")
def show_settings(message):
    settings_text = (
        "‚öôÔ∏è *Settings*\n\n"
        "üîß Settings coming soon:\n"
        "‚Ä¢ Default output format\n"
        "‚Ä¢ Auto-download option\n"
        "‚Ä¢ Code style preferences"
    )
    bot.send_message(message.chat.id, settings_text, parse_mode='Markdown')

@bot.message_handler(func=lambda m: m.text == "‚ùì Help")
def help_button(message):
    help_command(message)

@bot.message_handler(func=lambda message: True)
def convert_request(message):
    raw_data = message.text
    user_id = message.from_user.id
    
    valid_methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']
    if not any(raw_data.upper().startswith(m) for m in valid_methods):
        bot.reply_to(
            message, 
            "‚ùå *Invalid format!*\n\nRaw HTTP request bhejo jo GET, POST, PUT etc se start ho.\n\n/example command se format dekho.",
            parse_mode='Markdown'
        )
        return
    
    parsed = parse_raw_request(raw_data)
    
    if not parsed:
        bot.reply_to(message, "‚ùå Request parse nahi ho payi. Format check karo!\n\n/example se correct format dekho.")
        return
    
    if user_id not in user_requests:
        user_requests[user_id] = []
    
    user_requests[user_id].append({
        'method': parsed['method'],
        'url': parsed['url'],
        'parsed': parsed,
        'timestamp': datetime.now().isoformat()
    })
    
    confirm_text = (
        "‚úÖ *Request Parsed Successfully!*\n\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üì° *Method:* `{parsed['method']}`\n"
        f"üîó *URL:* `{parsed['url'][:50]}...`\n"
        f"üìã *Headers:* {len(parsed['headers'])}\n"
        f"üì¶ *Body:* {len(parsed['body'])} chars\n"
        f"üç™ *Cookies:* {len(parsed['cookies'])}\n"
        "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        "üëá *Output format select karo:*"
    )
    
    bot.send_message(
        message.chat.id,
        confirm_text,
        parse_mode='Markdown',
        reply_markup=get_format_keyboard()
    )

# ================== CALLBACK HANDLERS ==================

@bot.callback_query_handler(func=lambda call: call.data.startswith('format_'))
def handle_format_selection(call):
    user_id = call.from_user.id
    format_type = call.data.replace('format_', '')
    
    if user_id not in user_requests or not user_requests[user_id]:
        bot.answer_callback_query(call.id, "‚ùå No request found! Please send a new request.")
        return
    
    parsed = user_requests[user_id][-1]['parsed']
    
    bot.answer_callback_query(call.id, f"‚è≥ Generating {format_type.upper()}...")
    
    format_generators = {
        'php': ('PHP cURL', generate_php_curl, 'php'),
        'python': ('Python Requests', generate_python_requests, 'python'),
        'httpx': ('Python HTTPX', generate_python_httpx, 'python'),
        'curl': ('cURL Command', generate_curl_command, 'bash'),
        'nodejs': ('Node.js Fetch', generate_nodejs_fetch, 'javascript'),
        'axios': ('Node.js Axios', generate_nodejs_axios, 'javascript'),
        'jsbrowser': ('JavaScript Browser', generate_javascript_fetch, 'javascript'),
        'golang': ('Golang', generate_golang, 'go'),
        'java': ('Java', generate_java, 'java'),
        'csharp': ('C#', generate_csharp, 'csharp'),
        'ruby': ('Ruby', generate_ruby, 'ruby'),
        'guzzle': ('PHP Guzzle', generate_php_guzzle, 'php')
    }
    
    if format_type == 'all':
        for fmt, (name, generator, lang) in format_generators.items():
            try:
                code = generator(parsed)
                response = f"‚úÖ *{name}:*\n```{lang}\n{code}\n```"
                
                if len(response) > 4000:
                    ext_map = {'php': 'php', 'python': 'py', 'bash': 'sh', 'javascript': 'js', 
                               'go': 'go', 'java': 'java', 'csharp': 'cs', 'ruby': 'rb'}
                    ext = ext_map.get(lang, 'txt')
                    filename = f"{fmt}_code.{ext}"
                    
                    with open(filename, 'w') as f:
                        f.write(code)
                    
                    bot.send_document(call.message.chat.id, open(filename, 'rb'), caption=f"‚úÖ {name}")
                    os.remove(filename)
                else:
                    bot.send_message(call.message.chat.id, response, parse_mode='Markdown')
            except Exception as e:
                bot.send_message(call.message.chat.id, f"‚ùå Error generating {name}: {str(e)}")
        return
    
    if format_type not in format_generators:
        bot.answer_callback_query(call.id, "‚ùå Invalid format!")
        return
    
    name, generator, lang = format_generators[format_type]
    
    try:
        code = generator(parsed)
        response = f"‚úÖ *{name}:*\n```{lang}\n{code}\n```"
        
        if len(response) > 4000:
            ext_map = {'php': 'php', 'python': 'py', 'bash': 'sh', 'javascript': 'js', 
                       'go': 'go', 'java': 'java', 'csharp': 'cs', 'ruby': 'rb'}
            ext = ext_map.get(lang, 'txt')
            filename = f"{format_type}_code.{ext}"
            
            with open(filename, 'w') as f:
                f.write(code)
            
            bot.send_document(
                call.message.chat.id, 
                open(filename, 'rb'),
                caption=f"‚úÖ {name}",
                reply_markup=get_back_keyboard()
            )
            os.remove(filename)
        else:
            bot.send_message(
                call.message.chat.id, 
                response, 
                parse_mode='Markdown',
                reply_markup=get_back_keyboard()
            )
    except Exception as e:
        bot.send_message(call.message.chat.id, f"‚ùå Error: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data == 'download_all')
def download_all_formats(call):
    user_id = call.from_user.id
    
    if user_id not in user_requests or not user_requests[user_id]:
        bot.answer_callback_query(call.id, "‚ùå No request found!")
        return
    
    parsed = user_requests[user_id][-1]['parsed']
    bot.answer_callback_query(call.id, "‚è≥ Generating all files...")
    
    files = [
        ('php_curl.php', generate_php_curl(parsed)),
        ('python_requests.py', generate_python_requests(parsed)),
        ('python_httpx.py', generate_python_httpx(parsed)),
        ('curl_command.sh', generate_curl_command(parsed)),
        ('nodejs_fetch.js', generate_nodejs_fetch(parsed)),
        ('nodejs_axios.js', generate_nodejs_axios(parsed)),
        ('browser_fetch.js', generate_javascript_fetch(parsed)),
        ('golang_http.go', generate_golang(parsed)),
        ('java_http.java', generate_java(parsed)),
        ('csharp_http.cs', generate_csharp(parsed)),
        ('ruby_http.rb', generate_ruby(parsed)),
        ('php_guzzle.php', generate_php_guzzle(parsed))
    ]
    
    for filename, content in files:
        try:
            with open(filename, 'w') as f:
                f.write(content)
            
            bot.send_document(call.message.chat.id, open(filename, 'rb'), caption=f"üìÑ {filename}")
            os.remove(filename)
        except Exception as e:
            bot.send_message(call.message.chat.id, f"‚ùå Error creating {filename}: {str(e)}")
    
    bot.send_message(call.message.chat.id, "‚úÖ All files sent!")

@bot.callback_query_handler(func=lambda call: call.data == 'back_formats')
def back_to_formats(call):
    bot.edit_message_reply_markup(
        call.message.chat.id,
        call.message.message_id,
        reply_markup=get_format_keyboard()
    )

# ================== RUN BOT ==================

if __name__ == "__main__":
    print("=" * 50)
    print("ü§ñ Raw Request Converter Bot")
    print("=" * 50)
    print("‚úÖ Bot started successfully!")
    print("üì° Listening for messages...")
    print("=" * 50)
    
    bot.remove_webhook()
    bot.infinity_polling(skip_pending=True)